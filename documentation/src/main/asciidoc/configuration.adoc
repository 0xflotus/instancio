== Configuration

Instancio configuration is encapsulated by the {Settings} class, a map of keys and corresponding values.
The `Settings` class provides a few static methods for creating settings.

====
.Settings static factory methods
[source%nowrap,java]
----
Settings.create()                        // <1>
Settings.defaults()                      // <2>
Settings.from(Map<Object, Object> map)   // <3>
Settings.from(Settings other)            // <4>
----
====

<1> Creates a new instance of blank settings.
<2> Creates a new instance of default settings.
<3> Creates settings from a `Map` or `java.util.Properties`.
<4> Creates a copy of `other` settings (a clone operation).

Settings can be overridden programmatically or through a properties file.

[NOTE]
====
To inspect all the keys and default values, simply: +
`System.out.println(Settings.defaults())`
====

=== Overriding Settings Programmatically

To override programmatically, an instance of `Settings` can be passed in to the builder API:

====
.Supplying custom settings
[source%nowrap,java]
----
Settings overrides = Settings.create()
    .set(Keys.COLLECTION_MIN_SIZE, 10)     // <1>
    .set(Keys.STRING_ALLOW_EMPTY, true)
    .lock();                               // <2>

Person person = Instancio.of(Person.class)
    .withSettings(overrides)               // <3>
    .create();
----
====

<1> The {Keys} class provides static fields for all the keys supported by Instancio.
<2> The `lock()` method makes the settings instance immutable.
This is an optional method call.
It can be used to prevent modifications if settings are shared across multiple methods or classes.
<3> The passed in settings instance will override default settings.

=== Overriding Settings Using a Properties File

The {Keys} class defines a _property key_ for every key object, for example:

- `Keys.COLLECTION_MIN_SIZE` -> `"collection.min.size"`
- `Keys.STRING_ALLOW_EMPTY`  -> `"string.allow.empty"`

Using these property keys, configuration values can also be overridden via a properties file.
This can be done by placing `instancio.properties` at the root of the classpath and using property keys to override values (see the <<instancio-properties, sample properties file>>).

[[settings-precedence]]
=== Settings Precedence

Instancio layers settings on top of each other, each layer overriding the previous ones.
This is done in the following order:

. `Settings.defaults()`
. Settings from `instancio.properties`
. Settings injected into a JUnit test using `@WithSettings` annotation (see <<settings-injection, Settings Injection>>)
. Settings supplied to the builder API's `withSettings(Settings)` method

Therefore, settings supplied manually take precedence over everything else.

=== A Listing of all Supported Property Keys

[#instancio-properties]
====
.Sample configuration properties
[source%nowrap,properties]
----
array.elements.nullable=false  // <1>
array.max.length=6
array.min.length=2
array.nullable=false           // <2>
boolean.nullable=false
byte.max=127
byte.min=1
byte.nullable=false
character.nullable=false
collection.elements.nullable=false  // <1>
collection.max.size=6
collection.min.size=2
collection.nullable=false
double.max=10000
double.min=1
double.nullable=false
float.max=10000
float.min=1
float.nullable=false
integer.max=10000
integer.min=1
integer.nullable=false
long.max=10000
long.min=1
long.nullable=false
map.keys.nullable=false    // <1>
map.max.size=6
map.min.size=2
map.nullable=false
map.values.nullable=false  // <1>
short.max=10000
short.min=1
short.nullable=false
string.allow.empty=false
string.max.length=9
string.min.length=3
string.nullable=false
type.mapping.java.util.Collection=java.util.ArrayList  // <3>
type.mapping.java.util.List=java.util.ArrayList
type.mapping.java.util.Map=java.util.HashMap
type.mapping.java.util.SortedMap=java.util.TreeMap
----
====

<1> These keys specify whether Instancio can generate `null` values for array/collection elements and map keys and values.
<2> The `nullable` property specifes whether Instancio can generate `null` values for a given type.
<3> Properties prefixed with `type.mapping` are used to specify default implementations for abstract types, or map types to subtypes in general.
This is the same mechanism as <<subtype-mapping, Subtype Mapping>> but configured via properties.
